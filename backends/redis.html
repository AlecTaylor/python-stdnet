<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Redis &mdash; python stdnet 0.8.3b1 documentation</title>
    
    <link rel="stylesheet" href="../static/pulsar.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.3b1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="top" title="python stdnet 0.8.3b1 documentation" href="../index.html" />
    <link rel="up" title="Backend Servers" href="index.html" />
    <link rel="next" title="Mongo DB" href="mongo.html" />
    <link rel="prev" title="API" href="api.html" /> 
  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mongo.html" title="Mongo DB"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="api.html" title="API"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">python stdnet 0.8.3b1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Backend Servers</a> &raquo;</li> 
      </ul>
    </div>
<div class="deck">
<div class="header">
    
        <p class="developmentversion">
        Documentation for pulsar's DEVELOPMENT version. Get the 
        <a href="http://packages.python.org/python-stdnet/">release docs here</a>.
        </p>
    
</div>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="redis">
<span id="redis-server"></span><h1>Redis<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="http://redis.io/">Redis</a> is an advanced key-value store where each key is associated with a value.
What makes <a class="reference external" href="http://redis.io/">Redis</a> different from many other key-value databases, is that values can
be of different types:</p>
<blockquote>
<div><ul class="simple">
<li>Strings</li>
<li>Lists</li>
<li>Sets</li>
<li>Sorted Sets</li>
<li>Hash tables</li>
</ul>
</div></blockquote>
<p>In other words, you can look at redis as a data structure server, the networked
equivalent of the <a class="reference external" href="http://www2.roguewave.com/support/docs/hppdocs/stdref/index.html">standard template library in C++</a>.</p>
<p><a class="reference external" href="http://redis.io/">Redis</a> loads and maintains the whole data-set into memory, but the data-set
is persistent,
since at the same time it is saved on disk, so that when the server is restarted
data can be loaded back in memory. If you need speed, <a class="reference external" href="http://redis.io/">Redis</a> is great solution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">stdnet</span></tt> is a made up word from <tt class="docutils literal"><span class="pre">std</span></tt> for Standard Template Library
and <tt class="docutils literal"><span class="pre">net</span></tt> for networked.</p>
</div>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://github.com/andymccurdy/redis-py">redis-py</a>, provides the standard redis client.</li>
<li><a class="reference external" href="https://pypi.python.org/pypi/pulsar">pulsar</a> optional. It is required by the <a class="reference internal" href="#redis-async"><em>asynchronous connection</em></a>
and the <a class="reference internal" href="#redis-pubsub"><em>publish/subscribe redis</em></a> application.</li>
</ul>
</div>
<div class="section" id="connection-string">
<span id="redis-connection-string"></span><h2>Connection String<a class="headerlink" href="#connection-string" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="index.html#connection-string"><em>connection string</em></a> is a way to specify
the various parameters of the backend to use. Redis supports the following
parameters:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">db</span></tt>, the database number.</li>
<li><tt class="docutils literal"><span class="pre">namespace</span></tt>, the namespace for all the keys used by the backend.</li>
<li><tt class="docutils literal"><span class="pre">password</span></tt>, database password.</li>
<li><tt class="docutils literal"><span class="pre">timeout</span></tt>, connection timeout (0 is an asynchronous connection).</li>
</ul>
<p>A full connection string could be:</p>
<div class="highlight-python"><pre>redis://127.0.0.1:6379?db=3&amp;password=bla&amp;namespace=test.&amp;timeout=5</pre>
</div>
</div>
<div class="section" id="model-data">
<h2>Model data<a class="headerlink" href="#model-data" title="Permalink to this headline">¶</a></h2>
<p>Each <a class="reference internal" href="../api/models.html#stdnet.odm.StdModel" title="stdnet.odm.StdModel"><tt class="xref py py-class docutils literal"><span class="pre">stdnet.odm.StdModel</span></tt></a> class has an associated <tt class="docutils literal"><span class="pre">base</span> <span class="pre">key</span></tt> which
specifies the namespace for all keys associated with it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">stdnet</span> <span class="kn">import</span> <span class="n">getdb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">stdnet.apps.searchengine</span> <span class="kn">import</span> <span class="n">WordItem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdb</span> <span class="o">=</span> <span class="n">getdb</span><span class="p">(</span><span class="s">&#39;redis://localhost:6379?db=7&amp;namespace=bla.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdb</span><span class="o">.</span><span class="n">basekey</span><span class="p">(</span><span class="n">WordItem</span><span class="o">.</span><span class="n">_meta</span><span class="p">)</span>
<span class="go">&#39;bla.searchengine.worditem&#39;</span>
</pre></div>
</div>
<div class="section" id="instances">
<h3>Instances<a class="headerlink" href="#instances" title="Permalink to this headline">¶</a></h3>
<p>Each <a class="reference internal" href="../api/models.html#stdnet.odm.StdModel" title="stdnet.odm.StdModel"><tt class="xref py py-class docutils literal"><span class="pre">stdnet.odm.StdModel</span></tt></a> instance is mapped into a redis <strong>Hash table</strong>.
The hash table key is uniquely evaluated by the model hash and
the <em>id</em> of the model instance and it is stored at:</p>
<div class="highlight-python"><pre>&lt;&lt;basekey&gt;&gt;:obj:&lt;&lt;id&gt;&gt;</pre>
</div>
<p>For example, a <tt class="docutils literal"><span class="pre">WordItem</span></tt> with id <tt class="docutils literal"><span class="pre">1</span></tt> is mapped by the database handler
in the code snipped above, into a redis hash table
at key <tt class="docutils literal"><span class="pre">bla.searchengine.worditem:obj:1</span></tt>.
The hash fields and values are given by the field name and values of the
model instance.</p>
</div>
<div class="section" id="indexes">
<h3>Indexes<a class="headerlink" href="#indexes" title="Permalink to this headline">¶</a></h3>
<p>Indexes are obtained by using sets with keys obtained using the
following form:</p>
<div class="highlight-python"><pre>&lt;&lt;basekey&gt;&gt;:idx:&lt;&lt;field name&gt;&gt;:&lt;&lt;field value&gt;&gt;</pre>
</div>
<p>If the model specify an <a class="reference internal" href="../examples/sorting.html#implicit-sorting"><em>implicit ordering</em></a> via the
<tt class="xref py py-attr docutils literal"><span class="pre">stdnet.odm.Metaclass.ordering</span></tt> attribute, indexes are stored
in sorted sets rather than sets.</p>
</div>
<div class="section" id="unique-constratins">
<h3>Unique Constratins<a class="headerlink" href="#unique-constratins" title="Permalink to this headline">¶</a></h3>
<p>For some models you may need to specify certain field to be unique across
the Model. For example the following <tt class="docutils literal"><span class="pre">User</span></tt> model:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">odm</span><span class="o">.</span><span class="n">StdModel</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">odm</span><span class="o">.</span><span class="n">SymbolField</span><span class="p">(</span><span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">emauil</span> <span class="o">=</span> <span class="n">odm</span><span class="o">.</span><span class="n">SymbolField</span><span class="p">(</span><span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">odm</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>specifies two constrains.
In redis these constraints are stored into two separate hash tables with
key given by:</p>
<div class="highlight-python"><pre>&lt;&lt;basekey&gt;&gt;:uni:&lt;&lt;field name&gt;&gt;</pre>
</div>
<p>Therefore our <tt class="docutils literal"><span class="pre">User</span></tt> model will have two additional hash tables at:</p>
<div class="highlight-python"><pre>&lt;&lt;basekey&gt;&gt;:uni:username
&lt;&lt;basekey&gt;&gt;:uni:email</pre>
</div>
<p>Each hash table map a field value to the <tt class="docutils literal"><span class="pre">id</span></tt> containing that value</p>
</div>
</div>
<div class="section" id="redis-session">
<span id="redis-parser"></span><h2>Redis Session<a class="headerlink" href="#redis-session" title="Permalink to this headline">¶</a></h2>
<p>Redis <a class="reference internal" href="../api/models.html#stdnet.odm.Session" title="stdnet.odm.Session"><tt class="xref py py-class docutils literal"><span class="pre">stdnet.odm.Session</span></tt></a> and <tt class="xref py py-class docutils literal"><span class="pre">Query</span></tt> are handled by lua scripts which
perform them in a single atomic operation.</p>
</div>
<div class="section" id="redis-query">
<h2>Redis Query<a class="headerlink" href="#redis-query" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="../api/models.html#stdnet.odm.Query" title="stdnet.odm.Query"><tt class="xref py py-class docutils literal"><span class="pre">stdnet.odm.Query</span></tt></a> is handled in redis by two different lua scripts:</p>
<ul class="simple">
<li>the first is script performs the aggregation of which results in a temporary
redis <tt class="docutils literal"><span class="pre">key</span></tt> holding the <tt class="docutils literal"><span class="pre">ids</span></tt> resulting from the query operations.</li>
<li>The second script is used to load the data from redis into the client.</li>
</ul>
<div class="section" id="aggregation">
<span id="redis-aggragation"></span><h3>Aggregation<a class="headerlink" href="#aggregation" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="loading">
<h3>Loading<a class="headerlink" href="#loading" title="Permalink to this headline">¶</a></h3>
<p>The list of arguments passed to the <tt class="xref py py-mod docutils literal"><span class="pre">stdnet.lib.lua.load_query</span></tt> script:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">query_key</span></tt>, the redis key holding the <tt class="docutils literal"><span class="pre">ids</span></tt>
from the <a class="reference internal" href="#redis-aggragation"><em>aggregation step</em></a>.</li>
<li><tt class="docutils literal"><span class="pre">basekey</span></tt> the prefix to apply to all keys in the model to aggregate.</li>
<li>List of field to loads as <tt class="docutils literal"><span class="pre">[num_fields,</span> <span class="pre">field1,</span> <span class="pre">...]</span></tt>. if <tt class="docutils literal"><span class="pre">num_fields</span></tt>
is <tt class="docutils literal"><span class="pre">0</span></tt>, all model fields will load.</li>
<li>List of related model to load as <tt class="docutils literal"><span class="pre">[num_rel_models,</span> <span class="pre">rel_models1,</span> <span class="pre">...]</span></tt>.</li>
</ul>
</div>
</div>
<div class="section" id="module-stdnet.backends.redisb.async">
<span id="asynchronous-connection"></span><span id="redis-async"></span><h2>Asynchronous Connection<a class="headerlink" href="#module-stdnet.backends.redisb.async" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-stdnet.backends.redisb.async" title="stdnet.backends.redisb.async"><tt class="xref py py-mod docutils literal"><span class="pre">stdnet.backends.redisb.async</span></tt></a> module implements an asynchronous
connector for <a class="reference external" href="https://github.com/andymccurdy/redis-py">redis-py</a>. It uses <a class="reference external" href="https://pypi.python.org/pypi/pulsar">pulsar</a> asynchronous framework.
To use this connector,
add <tt class="docutils literal"><span class="pre">timeout=0</span></tt> to redis <a class="reference internal" href="index.html#connection-string"><em>connection string</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&#39;redis://127.0.0.1:6378?password=bla&amp;timeout=0&#39;</span>
</pre></div>
</div>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">stdnet</span> <span class="kn">import</span> <span class="n">getdb</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">getdb</span><span class="p">(</span><span class="s">&#39;redis://127.0.0.1:6378?password=bla&amp;timeout=0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="asynchronous-publish-subscribe">
<span id="redis-pubsub"></span><h3>Asynchronous Publish/Subscribe<a class="headerlink" href="#asynchronous-publish-subscribe" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="stdnet.backends.redisb.async.PubSub">
<em class="property">class </em><tt class="descclassname">stdnet.backends.redisb.async.</tt><tt class="descname">PubSub</tt><big>(</big><em>connection_pool</em>, <em>shard_hint</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.async.PubSub" title="Permalink to this definition">¶</a></dt>
<dd><p>Asynchronous Publish/Subscriber handler for redis.</p>
<p>To listen for messages you can bind to the <tt class="docutils literal"><span class="pre">on_message</span></tt> event:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">stdnet</span> <span class="kn">import</span> <span class="n">getdb</span>

<span class="k">def</span> <span class="nf">handle_messages</span><span class="p">(</span><span class="n">channel_message</span><span class="p">):</span>
    <span class="o">...</span>
    
<span class="n">redis</span> <span class="o">=</span> <span class="n">getdb</span><span class="p">(</span><span class="s">&#39;redis://122.0.0.1:6379?timeout=0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">client</span>
<span class="n">pubsub</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">pubsub</span><span class="p">()</span>
<span class="n">pubsub</span><span class="o">.</span><span class="n">bind_event</span><span class="p">(</span><span class="s">&#39;on_message&#39;</span><span class="p">,</span> <span class="n">handle_messages</span><span class="p">)</span>
<span class="n">pubsub</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="s">&#39;mychannel&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="stdnet.backends.redisb.async.PubSub.channels">
<tt class="descname">channels</tt><a class="headerlink" href="#stdnet.backends.redisb.async.PubSub.channels" title="Permalink to this definition">¶</a></dt>
<dd><p>The set of channels this handler is subscribed to.</p>
</dd></dl>

<dl class="attribute">
<dt id="stdnet.backends.redisb.async.PubSub.patterns">
<tt class="descname">patterns</tt><a class="headerlink" href="#stdnet.backends.redisb.async.PubSub.patterns" title="Permalink to this definition">¶</a></dt>
<dd><p>The set of patterns this handler is subscribed to.</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.async.PubSub.publish">
<tt class="descname">publish</tt><big>(</big><em>channel</em>, <em>message</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.async.PubSub.publish" title="Permalink to this definition">¶</a></dt>
<dd><p>Publish a new <tt class="docutils literal"><span class="pre">message</span></tt> to a <tt class="docutils literal"><span class="pre">channel</span></tt>.</p>
<p>This method return a pulsar Deferred which results in the number of Subscribers
that will receive the message.</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.async.PubSub.subscribe">
<tt class="descname">subscribe</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.async.PubSub.subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Subscribe to a list of <tt class="docutils literal"><span class="pre">channels</span></tt> or <tt class="docutils literal"><span class="pre">channel</span> <span class="pre">patterns</span></tt>.</p>
<p>It returns an asynchronous component which results in the number of channels
this handler is subscribed to. If this is the first time the method is called by
this handler, than the <a class="reference internal" href="#stdnet.backends.redisb.async.PubSub" title="stdnet.backends.redisb.async.PubSub"><tt class="xref py py-class docutils literal"><span class="pre">PubSub</span></tt></a> starts listening for messages which
are fired via the <tt class="docutils literal"><span class="pre">on_message</span></tt> event.</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.async.PubSub.unsubscribe">
<tt class="descname">unsubscribe</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.async.PubSub.unsubscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-subscribe from a list of <tt class="docutils literal"><span class="pre">channels</span></tt> or <tt class="docutils literal"><span class="pre">channel</span> <span class="pre">patterns</span></tt>.</p>
<p>It returns an asynchronous component which results in the number of channels
this handler is subscribed to.</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.async.PubSub.close">
<tt class="descname">close</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.async.PubSub.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop listening for messages.</p>
<p><a class="reference internal" href="#stdnet.backends.redisb.async.PubSub.unsubscribe" title="stdnet.backends.redisb.async.PubSub.unsubscribe"><tt class="xref py py-meth docutils literal"><span class="pre">unsubscribe()</span></tt></a> from all <a class="reference internal" href="#stdnet.backends.redisb.async.PubSub.channels" title="stdnet.backends.redisb.async.PubSub.channels"><tt class="xref py py-attr docutils literal"><span class="pre">channels</span></tt></a> and <a class="reference internal" href="#stdnet.backends.redisb.async.PubSub.patterns" title="stdnet.backends.redisb.async.PubSub.patterns"><tt class="xref py py-attr docutils literal"><span class="pre">patterns</span></tt></a>
and close the subscriber connection with redis.</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.async.PubSub.parse_response">
<tt class="descname">parse_response</tt><big>(</big><em>connection</em>, <em>command_name</em>, <em>**params</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.async.PubSub.parse_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback from the <tt class="xref py py-class docutils literal"><span class="pre">AsyncRedisRequest</span></tt>.</p>
<p>This method is invoked multiple times when new <tt class="docutils literal"><span class="pre">results</span></tt> are available.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-stdnet.backends.redisb.client">
<span id="client-extensions"></span><h2>Client Extensions<a class="headerlink" href="#module-stdnet.backends.redisb.client" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-stdnet.backends.redisb.client" title="stdnet.backends.redisb.client"><tt class="xref py py-mod docutils literal"><span class="pre">stdnet.backends.redisb.client</span></tt></a> implements several extensions
to the standard redis client in <a class="reference external" href="https://github.com/andymccurdy/redis-py">redis-py</a></p>
<div class="section" id="client">
<h3>Client<a class="headerlink" href="#client" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="stdnet.backends.redisb.client.Redis">
<em class="property">class </em><tt class="descclassname">stdnet.backends.redisb.client.</tt><tt class="descname">Redis</tt><big>(</big><em>host='localhost'</em>, <em>port=6379</em>, <em>db=0</em>, <em>password=None</em>, <em>socket_timeout=None</em>, <em>connection_pool=None</em>, <em>charset='utf-8'</em>, <em>errors='strict'</em>, <em>decode_responses=False</em>, <em>unix_socket_path=None</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.Redis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="stdnet.backends.redisb.client.Redis.execute_command">
<tt class="descname">execute_command</tt><big>(</big><em>*args</em>, <em>**options</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.Redis.execute_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute a command and return a parsed response</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.client.Redis.parse_response">
<tt class="descname">parse_response</tt><big>(</big><em>connection</em>, <em>command_name</em>, <em>**options</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.Redis.parse_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Override <a class="reference external" href="https://github.com/andymccurdy/redis-py">redis-py</a> parse_response method to deal with scripts.</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.client.Redis.prefixed">
<tt class="descname">prefixed</tt><big>(</big><em>prefix</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.Redis.prefixed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#stdnet.backends.redisb.client.PrefixedRedis" title="stdnet.backends.redisb.client.PrefixedRedis"><tt class="xref py py-class docutils literal"><span class="pre">PrefixedRedis</span></tt></a> client</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.client.Redis.execute_script">
<tt class="descname">execute_script</tt><big>(</big><em>name</em>, <em>keys</em>, <em>*args</em>, <em>**options</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.Redis.execute_script" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute a registered lua script at <tt class="docutils literal"><span class="pre">name</span></tt>. The script must
be implemented via subclassing <a class="reference internal" href="#stdnet.backends.redisb.client.RedisScript" title="stdnet.backends.redisb.client.RedisScript"><tt class="xref py py-class docutils literal"><span class="pre">RedisScript</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; the name of the registered script.</li>
<li><strong>keys</strong> &#8211; tuple/list of keys pased to the script.</li>
<li><strong>args</strong> &#8211; argument passed to the script.</li>
<li><strong>options</strong> &#8211; key-value parameters passed to the <a class="reference internal" href="#stdnet.backends.redisb.client.RedisScript.callback" title="stdnet.backends.redisb.client.RedisScript.callback"><tt class="xref py py-meth docutils literal"><span class="pre">RedisScript.callback()</span></tt></a>
method once the script has finished execution.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.client.Redis.countpattern">
<tt class="descname">countpattern</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.Redis.countpattern" title="Permalink to this definition">¶</a></dt>
<dd><p>delete all keys matching <em>pattern</em>.</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.client.Redis.delpattern">
<tt class="descname">delpattern</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.Redis.delpattern" title="Permalink to this definition">¶</a></dt>
<dd><p>delete all keys matching <em>pattern</em>.</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.client.Redis.zdiffstore">
<tt class="descname">zdiffstore</tt><big>(</big><em>dest</em>, <em>keys</em>, <em>withscores=False</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.Redis.zdiffstore" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the difference of multiple sorted sets specified by
<tt class="docutils literal"><span class="pre">keys</span></tt> into a new sorted set, <tt class="docutils literal"><span class="pre">dest</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.client.Redis.zpopbyrank">
<tt class="descname">zpopbyrank</tt><big>(</big><em>name</em>, <em>start</em>, <em>stop=None</em>, <em>withscores=False</em>, <em>desc=False</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.Redis.zpopbyrank" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop a range by rank</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.client.Redis.zpopbyscore">
<tt class="descname">zpopbyscore</tt><big>(</big><em>name</em>, <em>start</em>, <em>stop=None</em>, <em>withscores=False</em>, <em>desc=False</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.Redis.zpopbyscore" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop a range by score</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="prefixed-client">
<h3>Prefixed Client<a class="headerlink" href="#prefixed-client" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="stdnet.backends.redisb.client.PrefixedRedis">
<em class="property">class </em><tt class="descclassname">stdnet.backends.redisb.client.</tt><tt class="descname">PrefixedRedis</tt><big>(</big><em>client</em>, <em>prefix</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.PrefixedRedis" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for a prefixed redis client. It append a prefix to all keys.</p>
<dl class="attribute">
<dt id="stdnet.backends.redisb.client.PrefixedRedis.prefix">
<tt class="descname">prefix</tt><a class="headerlink" href="#stdnet.backends.redisb.client.PrefixedRedis.prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>The prefix to append to all keys</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.client.PrefixedRedis.execute_command">
<tt class="descname">execute_command</tt><big>(</big><em>cmnd</em>, <em>*args</em>, <em>**options</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.PrefixedRedis.execute_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute a command and return a parsed response</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="redisscript">
<h3>RedisScript<a class="headerlink" href="#redisscript" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="stdnet.backends.redisb.client.RedisScript">
<em class="property">class </em><tt class="descclassname">stdnet.backends.redisb.client.</tt><tt class="descname">RedisScript</tt><big>(</big><em>script</em>, <em>name</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.RedisScript" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref py py-class docutils literal"><span class="pre">RedisScriptBase</span></tt> is a class which helps the sending and receiving
lua scripts to redis via the <tt class="docutils literal"><span class="pre">evalsha</span></tt> command.</p>
<dl class="attribute">
<dt id="stdnet.backends.redisb.client.RedisScript.script">
<tt class="descname">script</tt><a class="headerlink" href="#stdnet.backends.redisb.client.RedisScript.script" title="Permalink to this definition">¶</a></dt>
<dd><p>The lua script to run</p>
</dd></dl>

<dl class="attribute">
<dt id="stdnet.backends.redisb.client.RedisScript.required_scripts">
<tt class="descname">required_scripts</tt><a class="headerlink" href="#stdnet.backends.redisb.client.RedisScript.required_scripts" title="Permalink to this definition">¶</a></dt>
<dd><p>A list/tuple of other <a class="reference internal" href="#stdnet.backends.redisb.client.RedisScript" title="stdnet.backends.redisb.client.RedisScript"><tt class="xref py py-class docutils literal"><span class="pre">RedisScript</span></tt></a> names required by this script
to properly execute.</p>
</dd></dl>

<dl class="attribute">
<dt id="stdnet.backends.redisb.client.RedisScript.sha1">
<tt class="descname">sha1</tt><a class="headerlink" href="#stdnet.backends.redisb.client.RedisScript.sha1" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference external" href="http://en.wikipedia.org/wiki/SHA-1">SHA-1</a> hexadecimal representation of <a class="reference internal" href="#stdnet.backends.redisb.client.RedisScript.script" title="stdnet.backends.redisb.client.RedisScript.script"><tt class="xref py py-attr docutils literal"><span class="pre">script</span></tt></a> required by the
<tt class="docutils literal"><span class="pre">EVALSHA</span></tt> redis command. This attribute is evaluated by the library,
it is not set by the user.</p>
</dd></dl>

<dl class="method">
<dt id="stdnet.backends.redisb.client.RedisScript.callback">
<tt class="descname">callback</tt><big>(</big><em>response</em>, <em>**options</em><big>)</big><a class="headerlink" href="#stdnet.backends.redisb.client.RedisScript.callback" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the only method user should override when writing a new
<a class="reference internal" href="#stdnet.backends.redisb.client.RedisScript" title="stdnet.backends.redisb.client.RedisScript"><tt class="xref py py-class docutils literal"><span class="pre">RedisScript</span></tt></a>. By default it returns <tt class="docutils literal"><span class="pre">response</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>response</strong> &#8211; the response obtained from the script execution.</li>
<li><strong>options</strong> &#8211; Additional options for the callback.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><p class="logo">
<a href="../index.html">
  <img class="logo" width="200" src="../static/net.jpg" alt="Logo"/>
</a>
</p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Redis</a><ul>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#connection-string">Connection String</a></li>
<li><a class="reference internal" href="#model-data">Model data</a><ul>
<li><a class="reference internal" href="#instances">Instances</a></li>
<li><a class="reference internal" href="#indexes">Indexes</a></li>
<li><a class="reference internal" href="#unique-constratins">Unique Constratins</a></li>
</ul>
</li>
<li><a class="reference internal" href="#redis-session">Redis Session</a></li>
<li><a class="reference internal" href="#redis-query">Redis Query</a><ul>
<li><a class="reference internal" href="#aggregation">Aggregation</a></li>
<li><a class="reference internal" href="#loading">Loading</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-stdnet.backends.redisb.async">Asynchronous Connection</a><ul>
<li><a class="reference internal" href="#asynchronous-publish-subscribe">Asynchronous Publish/Subscribe</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-stdnet.backends.redisb.client">Client Extensions</a><ul>
<li><a class="reference internal" href="#client">Client</a></li>
<li><a class="reference internal" href="#prefixed-client">Prefixed Client</a></li>
<li><a class="reference internal" href="#redisscript">RedisScript</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="api.html"
                        title="previous chapter">API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="mongo.html"
                        title="next chapter">Mongo DB</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../sources/backends/redis.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
        &copy; Copyright 2010-2013, Luca Sbardella.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  
  _gaq.push(['_setAccount', 'UA-3900561-6']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>